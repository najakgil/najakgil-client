_프로젝트를 진행하면서 경험한 바를 솔직하게 적은 글입니다._   
_잘못된 내용이나 조언에 대한 피드백을 환영합니다.([이메일 주소](okdal20@gmail.com))_

**목차**   
[1. 기술 스택 & 선정 이유](https://github.com/najakgil/najakgil-client#1%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D--%EC%84%A0%EC%A0%95-%EC%9D%B4%EC%9C%A0)   
- [1.1. 기술 스택 선정 기준](https://github.com/najakgil/najakgil-client#11-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-%EC%84%A0%EC%A0%95-%EA%B8%B0%EC%A4%80)   
- [1.2. 구체적인 기술 스택 선정 이유](https://github.com/najakgil/najakgil-client#12-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EA%B8%B0%EC%88%A0-%EC%8A%A4%ED%83%9D-%EC%84%A0%EC%A0%95-%EC%9D%B4%EC%9C%A0)
 
[2. 베타 서비스 개발 과정에서 생각이 머무른 지점들](https://github.com/najakgil/najakgil-client#2%EB%B2%A0%ED%83%80-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%9C%EB%B0%9C-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EC%83%9D%EA%B0%81%EC%9D%B4-%EB%A8%B8%EB%AC%B4%EB%A5%B8-%EC%A7%80%EC%A0%90%EB%93%A4)   
- [2.1. container-presenter 패턴을 기반으로 한 폴더 구조의 실패](https://github.com/najakgil/najakgil-client#21%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%A0%EA%B9%8C)   
- [2.2. ’만들기 화면’에서 ‘미리보기 화면’으로 데이터 넘겨주는 방식](https://github.com/najakgil/najakgil-client#22%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%99%94%EB%A9%B4%EC%97%90%EC%84%9C-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0-%ED%99%94%EB%A9%B4%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%84%98%EA%B2%A8%EC%A3%BC%EB%8A%94-%EB%B0%A9%EC%8B%9D)   
- [2.3. 유저의 플로우 경험을 위해, 개발 측면에서 고려해야 할 점들](https://github.com/najakgil/najakgil-client#23%EC%9C%A0%EC%A0%80%EC%9D%98-%ED%94%8C%EB%A1%9C%EC%9A%B0-%EA%B2%BD%ED%97%98%EC%9D%84-%EC%9C%84%ED%95%B4-%EA%B0%9C%EB%B0%9C-%EC%B8%A1%EB%A9%B4%EC%97%90%EC%84%9C-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC-%ED%95%A0-%EC%A0%90%EB%93%A4)   

## 1. 기술 스택 & 선정 이유
### 1.1. 기술 스택 선정 기준
기술 스택 선정은 다음과 같은 두 가지 측면을 기준으로 선택하였다.

**1) 프로젝트 완성에 집중**

프로젝트 진행 시, 개발자의 성장과 프로젝트의 완성도 간에 비율을 적절히 유지해야 한다고 보았다. 새로운 기술을 사용하여 개발자의 성장을 도모할 수도 있지만, 이에 몰두되면 프로젝트 완성도에는 방해가 될 수도 있다고 생각하였다. 따라서 프로젝트를 완성할 수 있을 정도의 수준 내에서, 개발자의 성장을 꾀할 수 있도록 기술 스택을 선정하였다. 나작길 베타 서비스의 경우, TypeScript라는 언어를 처음으로 사용해보는 대신 CSS 프레임워크의 경우 기존에 사용하던 styled-components를 채택하여, 개발자의 성장과 프로젝트의 완성도 간의 비율을 유지하고자 하였다.

**2) 해커톤이라는 특수한 환경**

해커톤에서는 제한된 시간 내에 결과물을 도출해야 한다고 보았다. 따라서 개발적인 측면에서는 변수를 최소화하는 것 역시 필요한 역량으로 생각하였다. 또한 기획 측면에서는 주어진 자원 내에서 해결이 가능한 지와 뚜렷한 기획 의도가 있는지(트래픽이 높은 프로젝트를 하고자 원했음)를 염두하였다.

### 1.2. 구체적인 기술 스택 선정 이유

다음으로는 구체적인 기술 스택 선정 이유이다.
<div align='center'>
   <img width='50%' align='center' src='https://github.com/najakgil/najakgil-client/assets/97885933/51f48d73-6d49-44bd-94d3-d2298c66f3d8'/>
</div>

**1.2.1. React**

- 모바일 퍼스트 전략 채택
    - 주타겟층이 20대 대학생
    - 서비스 특성 상 모바일을 통한 유입이 많을 것으로 예상
- SPA가 모바일 퍼스터 전략에 부합하다고 판단
    - UX 개선, 속도 향상…
- 컴포넌트 재사용성

나작길은 20대 대학생을 타겟층으로 하기 때문에, 모바일을 통한 유입이 많을 것으로 예상하였다. 또한 서비스 특성상, 기존의 유사 서비스(예시. [내 트리를 꾸며줘](https://colormytree.me/))를 보더라도 기능상 데스크탑에 비해 모바일이 적합하다고 보았다. 이러한 이유로 모바일 퍼스트 전략을 선택하였다.

[UX 개선, 속도 향상 등의 이유로 SPA가 모바일 퍼스트 전략에 적합하다고 판단](https://ventionteams.com/blog/pros-cons-of-single-page-applications)하였다. 또한 컴포넌트를 통한 재사용성을 높이는 것이 단 시간 내 개발하는데 효과적이라고 보았다.(**참고**) 따라서 SPA를 기반으로 하는 React를 나작길 기술스택으로 선정하였다.

**1.2.2. Recoil**

- 해커톤이라는 특수한 상황 속에서 아래와 같은 사항을 고려함
    - 단 시간 내 결과물 도출
    - 변수 최소화
- 위의 이유로 Recoil을 사용하여 핵심 기능인 캐릭터 꾸미기를 구현하는 것이 적합하다고 판단
    - 그 외 선택지 : 서버로부터 데이터 받아오기, MSW…

나작길의 핵심 기능은 캐릭터 만들기 기능(예시 : 바캉스룩을 입은 캐릭터를 선택하기)이다. 이때 캐릭터 꾸미는 방식을 두고 1)서버로부터 데이터를 받아오거나, 2)MSW를 사용하여 Mocking API로 구현한 후, 백엔드 API가 나온 이후에 서버로부터 데이터를 받아오거나, 3)프론트 측에서 전역 상태 관리를 이용하는 방식이 있다고 판단하였다.

하지만 해커톤이라는 특성 상, 단 시간 내에 완성을 해야 하며 변수를 최소화(서버가 목표한 시간 내에 구축되지 못 하였을 경우 등)하는 것을 최우선으로 해야한다고 보았다. 따라서 Recoil을 사용하여 캐릭터 꾸미는 기능을 구현하였다.

**1.2.3. Fabric.js**

- 나작길의 모티브인 [개발진스 프로젝트](https://github.com/skojphy/dev-jeans-hy)의 기술 스택 참고

나작길 핵심 기능인 캐릭터 만들기 중 꾸미기 기능에서는, 텍스트를 삽입하거나 펜으로 그림을 그릴 수 있는 기능이 존재하였다. 이는 나직길 프로젝트의 모티브가 된 ‘개발진스’ 프로젝트에서 사용한 기술 스택을 참고하였다.

**1.2.4. TypeScript**

- 개발자 개인적인 사유
    - TypeScript 사용 경험을 얻기 위함
- 에러의 사전 방지
- 코드 가이드 및 자동 완성

TypeScript 도입에 있어서는 개인적인 사유와 개발적인 측면이 동시에 존재하였다. 먼저 개인적인 사유로는, 당시에 TypeScript 스터디를 마친 직후였기 때문에, 스터디에서 배운 내용을 프로젝트를 통해 직접 사용해보는 경험을 얻고 싶었다. 다음으로 개발적인 측면에서는 에러의 사전 방지와 코드 가이드 및 자동 완성을 통해 프로젝트의  완성도를 높이기 위해서였다. 덧붙여 스터디에 공부한 앞서 언급한 TypeScript의 필요성을 직접 확인해보기 위함도 존재한다.

**1.2.5. Vite**

- 빌드 속도
- 타입스크립트 설정의 간결성

기존 프로젝트에서는 CRA를 통한 프로젝트 초기 설정을 하였다. 하지만 [빌드 속도, 특히 타입스크립트 설정의 간결성을 이유](https://yozm.wishket.com/magazine/detail/1620/)로 Vite를 선택하였다.

**1.2.6. styled-components**

- 개발자 개인적인 사유
    - 기존에 사용한 경험이 있음
- 별도의 CSS 파일을 만들 필요가 없음.

styled-components 도입 또한 개발자 개인적인 요소가 작용한 부분과 개발적인 측면이 동시에 존재하였다. 먼저 개발자 개인적인 요소가 작용한 부분으로는, styled-components는 이미 사용한 경험이 있기 때문에 해커톤에서 빠르게 개발이 가능하다고 보았다. 다음으로 개발적인 측면에서는 JS 파일에서 사용이 가능하다는 점이었다. 별도의 CSS 파일을 만들 필요가 없기 때문에, 효과적으로 코드 관리할 수 있다고 판단하였다.

## 2. 베타 서비스 개발 과정에서 생각이 머무른 지점들
### 2.1. container-presenter 패턴을 기반으로 한 폴더 구조의 실패

> container-presenter 패턴 → container-presenter 패턴 사용 후기 → atomic 패턴으로 변경

- 폴더 구조는 프로젝트 통일성을 가지게 하는 요소라고 생각함
- 프로젝트 초기에는 container-presenter 패턴 채택
    - 실무에서 사용하는 방식
    - UI와 서버 연동 코드 분리하여 관리 가능
- container-presenter 패턴 사용 후기
    - 컴포넌트 활용을 제대로 못 함
    - 코드 직관성 저하
     ⇒ atomic 패턴 도입
    

폴더 구조는 협업 시, 팀원들 간에 원활한 개발의 토대가 되는 요소라고 보았다. 그 근본적인 이유로는 파일의 위치 등 폴더 구조가 프로젝트 전반에 있어서 통일성을 마련하기 때문이라고 생각하였다. 이러한 점에서 어떠한 폴더 구조를 채택할 지 고민이 많았다.
```markdown
// container-presenter 패턴

najakgil-client
├── public
|   └── assets
|       └── icon
|       └── image
└── src
   ├── home
   |  └── Home.container.tsx
   |  └── Home.presenter.tsx
   ├── make
   |  └── Make.container.tsx
   |  └── Make.presenter.tsx
   ├── preview
   |  └── Preview.container.tsx
   |  └── Preview.presenter.tsx
   └── mypage
      └── MyPage.container.tsx
      └── MyPage.presenter.tsx
```

이때 container-presenter 패턴을 추천받아 채택을 하였다. 채택 사유로는, [실무에서 사용한다는 점과 UI와 서버와의 연동을 구분지어 효과적으로 프로젝트를 관리할 수 있다고 하였기 때문](https://velog.io/@badassong/React-실무용-폴더구조-props)이다. 이를 직접 확인하고자, container-presenter 패턴을 도입하였다.

직접 container-presenter 패턴을 사용해보니, 다음과 같은 바를 경험하였다. **1) 컴포넌트라는 React의 강점을 제대로 사용할 수 없다. 2) 한 파일 내 코드가 모든 코드가 들어가다보니, 코드 직관성이 떨어진다.** 두 이유를 연결지어 말해보자면, 만들기 페이지 내에 들어가는 모든 코드는 ‘Make.presenter.tsx’ 파일 내에 작성되었다. 그러다보니, 본인이 작성한 코드임에도 알아보는데 어려움이 존재하였다. 또한 컴포넌트 재사용성을 제대로 활용하지 못 하였다. 이를 토대로, 1인이었기에 작업이 가능하였지 해당 폴더 구조로는 협업에서는 언급한 단점들이 더욱 부각될 것이라고 판단하였다. 덧붙여 container-presenter 패턴의 경우, [Hook이 도입되기 이전에 유행한 패턴이라는 점도 새로 알게 되었다.](https://www.notion.so/e9feec0393574f6db0126f8ca7d81801?pvs=21)

위의 이유로 폴더 구조를 container-presenter 패턴에서 atomic 패턴으로 마이그레이션하기로 결정하였다(진행 예정). 폴더 구조는 아래와 같이, 결정하였다. 크게 components 폴더와 각 페이지 별로 폴더를 구성한다. 이때 components 폴더에서는 프로젝트 전반에 사용되는 공통 컴포넌트 파일을 관리한다. 다음으로 각 페이지 폴더는 다시 components 폴더와 페이지 파일로 구성되는데, 페이지 폴더 내 components에서는 페이지에 해당하는 컴포넌트를 관리하고자 한다. 이렇게 폴더를 구성하면 위에서 경험한 문제들이 해소될 것이라고 생각하였다.
```markdown
// atomic 패턴

najakgil-client
├── public
|   └── assets
|       └── icon
|       └── image
└── src
   ├── components
   |  └── Header
   |  └── BottomNav
	 | 	└── ...
   |
   ├── home
   |  └── components
   |  └── HomePage.tsx
   ├── make
   |  └── components
   |  └── MakePage.tsx
   ├── preview
   |  └── components
   |  └── PreviewPage.tsx
   └── mypage
      └── components
      └── MyPage.tsx
```
### 2.2. ’만들기 화면’에서 ‘미리보기 화면’으로 데이터를 넘겨주는 방식
[문제 상황]
- fabricjs-react 토대로 구현한 꾸미기 기능의 경우, 선택한 데이터를 미리보기 화면으로 어떻게 넘겨주어야 하는지 고민이 됨.    

[해결 방법]
- 만들기 화면에서 꾸민 캐릭터를 이미지화하여 base64로 변환해 미리보기 화면에 데이터를 넘겨줌.

나작길의 경우, 만들기 화면에서 유저가 캐릭터를 선택하고 캐릭터를 꾸밀 수도 있다. 이를 Make.presenter.tsx 파일 내 View 태그를 통해서 보여준다. 유저가 선택을 완료하면, 완성하기를 통해 미리보기 화면으로 이동하는 식으로 플로우가 진행이 된다.

이때 만들기 화면에서 선택된 값들(캐릭터, 꾸미기 > 텍스트 등)이 미리보기 화면으로 어떻게 데이터를 넘겨줘야 하는지 고민이 되었다. 

초기에는 아래와 같이 캐릭터, 꾸미기, 배경 개별 Atom으로 데이터를 넘겨주고자 하였다. 문제는 꾸미기의 경우 fabricjs-react 토대로 기능을 구현하였는데, 유저가 선택한 꾸미기 데이터를 어떻게 Recoil로 구현해야 할 지 방법이 생각나지 않았다.

```markdown
캐릭터 → ChracterChoiceAtom.tsx

배경화면 > 색상 → BackgroundColorChoiceAtom.tsx

배경화면 > 이미지 → BackgroundImageChoiceAtom.tsx

...
```

해커톤이라는 제한된 시간 내에 목표한 바를 구현해내야하였기 때문에 다음과 같은 방식을 시도하여 문제를 해결하였다. 만들기 화면에서 View 태그를 통해 보이는 화면을 이미지화하였다. 이미지는 base64로 변환하여 PreviewCardAtom을 통해 미리보기 화면으로 데이터를 넘겨주었다.

### 2.3. 유저의 플로우 경험을 위해, 개발 측면에서 고려해야 할 점들

- 핵심 기능 위주로 빠르게 개발하여 배포 후, 유저의 반응을 확인하고자 함
- 유저의 실제 피드백을 얻고자 방법을 설계함 → 참여형 이벤트 주최
    - 가설에 적합한 유저를 선발하고자 노력하였음
        - 가설 : 나작길 서비스 사용 경험이 있으며, 관심도가 높은 유저가 유효한 피드백을 해줄 것이다
    - 적극적 투자지표 측면에서 별도의 신청 절차를 거치도록 함
- [실제 유저 피드백을 수집할 수 있었고](https://proximal-agenda-6e1.notion.site/dee0957293c54ac7b77a1d2a4ffee16f?pvs=4), 이를 관리하고 있으며 우선순위를 토대로 반영하고 있는 중
    - 유저 피드백 일부
        - 이미지 드래그 현상 발생
        - 새로고침 시, 진행 중이던 꾸미기 데이터가 초기화됨
        - …

나작길의 경우, 핵심 기능만을 구현한 후 빠르게 배포를 하여 유저의 반응을 확인하고자 하였다. 그 이후 유저의 피드백을 반영하여 수정 및 보완하여 재배포를 하기로 계획하였다.

또한 유저의 실제 피드백을 얻고자, 참여형 이벤트를 주최하였다. 실제 서비스를 사용한 경험이 있고 서비스에 대한 관심도가 높은 사람이라면, 나작길 서비스에 대해 유효한 피드백을 해줄 수 있다고 가설을 세웠다. 해당 가설에 적합한 유저와 컨택을 하기 위해, (적극적 투자지표 측면에서) 별도의 신청 절차를 밟아 나작길 스티커를 배부하는 참여형 이벤트를 진행하였다.

그 결과 여러 피드백을 수집할 수 있었다. 대표적으로 이미지 드래그이다. 나작길의 경우, 이미지가 중점이 되는 서비스인데, 유저가 이미지 클릭 시 드래그가 발생하여 유저의 플로우를 방해하는 요소로 작용이 되었다. 따라서 아래 코드를 적용하여 해당 문제를 해결하였다.

```markdown
img {
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  -user-drag: none;
}
```

위에서 언급한 사례말고도, 다양한 피드백을 얻었으며 이를 노션 페이지를 통해 관리하고 있다. 우선순위를 토대로, 유저의 플로우 경험을 위해 다양한 시각에 개발적인 측면을 고려해야 함을 느낄 수 있었다.
